name: Articles Auto Translate
run-name: ${{ github.event.label.name }} - ${{ github.event.issue.title }}

on:
  issues:
    types: [labeled]

concurrency:
  group: auto-translate-${{ github.event.issue.number }}
  cancel-in-progress: false

permissions:
  issues: write
  contents: write

jobs:
  validate:
    name: Validate trigger and inputs
    runs-on: ubuntu-latest
    outputs:
      is_valid: ${{ steps.validate.outputs.is_valid }}
      skip_reason: ${{ steps.validate.outputs.skip_reason }}
      article_url: ${{ steps.validate.outputs.article_url }}
      article_title: ${{ steps.validate.outputs.article_title }}
      lang_code: ${{ steps.validate.outputs.lang_code }}
    steps:
      - name: Validate that the labeled tag is 'auto' and parse inputs
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            const label = context.payload.label?.name?.toLowerCase() || '';
            // Must be triggered by adding the 'auto' label
            if (label !== 'auto') {
              core.setOutput('is_valid', 'false');
              core.setOutput('skip_reason', `Trigger label '${label}' is not 'auto'`);
              return;
            }

            const issueBody = context.payload.issue?.body || '';
            if (!issueBody.trim()) {
              core.setOutput('is_valid', 'false');
              core.setOutput('skip_reason', 'Issue body is empty');
              return;
            }

            // extract markdown link [Title](URL)
            const m = issueBody.match(/\[([^\]]+)\]\((https?:\/\/[^\)]+)\)/);
            if (!m) {
              core.setOutput('is_valid', 'false');
              core.setOutput('skip_reason', 'Issue body must contain a markdown link: [Title](URL)');
              return;
            }
            const articleTitle = m[1];
            const articleUrl = m[2];

            // extract language code from issue title like [zh]
            const issueTitle = context.payload.issue?.title || '';
            const t = issueTitle.match(/^\[([a-zA-Z]{2,3})\]/);
            if (!t) {
              core.setOutput('is_valid', 'false');
              core.setOutput('skip_reason', 'Issue title must start with [lang]');
              return;
            }
            const langCode = t[1].toLowerCase();

            core.setOutput('is_valid', 'true');
            core.setOutput('article_url', articleUrl);
            core.setOutput('article_title', articleTitle);
            core.setOutput('lang_code', langCode);

  auto-translate:
    name: Auto translate (runs when label == 'auto')
    needs: validate
    runs-on: ubuntu-latest
    if: needs.validate.outputs.is_valid == 'true'
    steps:
      - name: Notify: started
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: 'Auto-translation job started. Preparing files...'
            });

      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup git
        run: |
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          git config pull.rebase true

      - name: Set env from validate
        run: |
          echo "ARTICLE_URL=${{ needs.validate.outputs.article_url }}" >> $GITHUB_ENV
          echo "ARTICLE_TITLE=${{ needs.validate.outputs.article_title }}" >> $GITHUB_ENV
          echo "LANG_CODE=${{ needs.validate.outputs.lang_code }}" >> $GITHUB_ENV

      - name: Fetch article and convert to Markdown
        id: fetch
        uses: freecodecamp/article-webpage-to-markdown-action@dev
        with:
          newsLink: "${{ env.ARTICLE_URL }}"
          includeSelector: 'span.author-card-name,section.post-content'
          ignoreSelector: '.ad-wrapper'
          skipSameArticleCheck: true
          skipIssueComment: true
          markDownFilePath: './articles/_tmp/'
          githubToken: "${{ github.token }}"

      - name: Sanitize filename
        id: sanitize
        run: |
          FETCHED_FILE="${{ steps.fetch.outputs.markdown_file_path }}"

          if [ -z "$FETCHED_FILE" ] || [ ! -f "$FETCHED_FILE" ]; then
            echo "Fetched file does not exist: $FETCHED_FILE"
            exit 1
          fi

          BASENAME=$(basename "$FETCHED_FILE")
          SAFE_BASENAME=$(echo "$BASENAME" | sed 's/[^a-zA-Z0-9._-]/-/g')

          if [[ ! "$SAFE_BASENAME" =~ \.md$ ]]; then
            SAFE_BASENAME="${SAFE_BASENAME%.md}.md"
          fi

          SAFE_BASENAME="${SAFE_BASENAME#.}"

          if [ -z "$SAFE_BASENAME" ] || [ "$SAFE_BASENAME" = ".md" ]; then
            echo "Invalid filename after sanitization"
            exit 1
          fi

          echo "filename=$SAFE_BASENAME" >> $GITHUB_OUTPUT
          echo "Sanitized filename: $SAFE_BASENAME"

      - name: Backup fetched Markdown to /tmp
        id: backup
        run: |
          FETCHED_FILE="${{ steps.fetch.outputs.markdown_file_path }}"
          SAFE_FILENAME="${{ steps.sanitize.outputs.filename }}"
          BACKUP="/tmp/$SAFE_FILENAME"
          mkdir -p /tmp
          cp "$FETCHED_FILE" "$BACKUP"
          echo "path=$BACKUP" >> $GITHUB_OUTPUT

      - name: Upload raw markdown to main branch (create or update)
        id: upload_raw
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = 'main';
            const filename = `${{ steps.sanitize.outputs.filename }}`;
            const rawPath = `articles/_raw/${filename}`;
            const localPath = path.join(process.cwd(), 'articles', '_tmp', filename);

            // If the fetch action put file in different path, fall back to /tmp backup
            let readPath = localPath;
            if (!fs.existsSync(readPath)) {
              const tmpPath = `/tmp/${filename}`;
              if (fs.existsSync(tmpPath)) {
                readPath = tmpPath;
              } else {
                core.setFailed(`Raw markdown not found at ${localPath} or /tmp/${filename}`);
                return;
              }
            }

            const content = fs.readFileSync(readPath, { encoding: 'base64' });

            // get existing file sha if present
            let sha;
            try {
              const { data: existing } = await github.rest.repos.getContent({
                owner, repo, path: rawPath, ref: branch
              });
              sha = existing.sha;
            } catch (err) {
              if (err.status !== 404) throw err;
            }

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path: rawPath,
              message: `Add/Update raw article: ${rawPath}`,
              content,
              branch,
              sha
            });

      - name: Ensure auto-translate branch exists (create from main if missing)
        id: ensure_branch
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = 'auto-translate';
            try {
              await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` });
              core.info(`${branch} exists`);
            } catch (err) {
              if (err.status === 404) {
                const mainRef = await github.rest.git.getRef({ owner, repo, ref: 'heads/main' });
                const mainSha = mainRef.data.object.sha;
                await github.rest.git.createRef({
                  owner, repo,
                  ref: `refs/heads/${branch}`,
                  sha: mainSha
                });
                core.info(`${branch} created from main`);
              } else {
                throw err;
              }
            }

      - name: Run articles-auto-translate action
        id: translate
        uses: freeCodeCamp/articles-auto-translate-action@main
        with:
          with_issue_title: "${{ github.event.issue.title }}"
          with_issue_body: "${{ github.event.issue.body }}"
          with_label_name: "auto"
          with_github_token: "${{ github.token }}"
          with_original_markdown_file_path: "${{ steps.backup.outputs.path }}"
          with_task_fetch_to_save_path: "./articles/_raw/"
          with_task_translate_openai_api_key: "${{ secrets.OPENAI_API_KEY }}"
          with_task_translate_to_save_path: "./articles/{lang}/"

      - name: Upload translated file to auto-translate branch (atomic)
        id: upload_translated
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = 'auto-translate';
            const filename = `${{ steps.sanitize.outputs.filename }}`;
            const lang = `${{ env.LANG_CODE }}`;
            const filePath = `articles/${lang}/${filename}`;
            const localPath = path.join(process.cwd(), 'articles', lang, filename);

            if (!fs.existsSync(localPath)) {
              core.setFailed(`Translated file not found at ${localPath}`);
              return;
            }

            const content = fs.readFileSync(localPath, { encoding: 'base64' });

            // check if file exists on branch to get sha
            let sha;
            try {
              const { data: existing } = await github.rest.repos.getContent({
                owner, repo, path: filePath, ref: branch
              });
              sha = existing.sha;
            } catch (err) {
              if (err.status !== 404) throw err;
            }

            const message = `Update translated article: ${filePath} (by workflow run ${process.env.GITHUB_RUN_ID})`;
            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path: filePath,
              message,
              content,
              branch,
              sha
            });
            core.info(`Uploaded ${filePath} to branch ${branch}`);

      - name: Extract author link and name from original article HTML
        id: extract_author
        run: |
          URL="${{ needs.validate.outputs.article_url }}"
          TMPHTML="/tmp/article.html"
          curl -sL "$URL" -o "$TMPHTML"
          AUTHOR_URL=""
          AUTHOR_NAME=""
          # try to find absolute author link first
          AUTHOR_URL=$(grep -oP 'href="https?://[^"]*/news/author/[^"]+' "$TMPHTML" | head -n1 | sed 's/href="//' || true)
          if [ -z "$AUTHOR_URL" ]; then
            # try relative author link
            REL=$(grep -oP 'href="\/news\/author\/[^"]+' "$TMPHTML" | head -n1 | sed 's/href="//' || true)
            if [ -n "$REL" ]; then
              AUTHOR_URL="https://www.freecodecamp.org${REL}"
            fi
          fi
          # extract author name from author link text or meta author
          AUTHOR_NAME=$(grep -oP '<a[^>]*\/news\/author\/[^"]*\"[^>]*>([^<]+)' "$TMPHTML" | sed -E 's/.*>([^<]+)<.*/\1/' | head -n1 || true)
          if [ -z "$AUTHOR_NAME" ]; then
            AUTHOR_NAME=$(grep -oP '<meta name="author" content="[^"]+' "$TMPHTML" | sed -E 's/.*content="//' | head -n1 || true)
          fi
          if [ -z "$AUTHOR_NAME" ]; then
            AUTHOR_NAME="Unknown"
          fi
          echo "author_name=$AUTHOR_NAME" >> $GITHUB_OUTPUT
          echo "author_url=$AUTHOR_URL" >> $GITHUB_OUTPUT
          echo "AUTHOR_NAME=$AUTHOR_NAME" >> $GITHUB_ENV
          echo "AUTHOR_URL=$AUTHOR_URL" >> $GITHUB_ENV

      - name: Post final standardized comment (exact required format)
        uses: actions/github-script@v7
        with:
          script: |
            const repo = context.repo.owner + '/' + context.repo.repo;
            const filename = `${{ steps.sanitize.outputs.filename }}`;
            const lang = `${{ env.LANG_CODE }}`;
            const articleUrl = `${{ needs.validate.outputs.article_url }}`;
            const articleTitle = `${{ needs.validate.outputs.article_title }}`;
            const authorName = `${{ steps.extract_author.outputs.author_name }}` || `${{ env.AUTHOR_NAME }}` || 'Unknown';
            const authorUrl = `${{ steps.extract_author.outputs.author_url }}` || '';
            const rawUrl = `https://github.com/${repo}/blob/main/articles/_raw/${filename}`;
            const translatedEditUrl = `https://github.com/${repo}/edit/auto-translate/articles/${lang}/${filename}`;
            const githubDevUrl = `https://github.dev/${repo}/blob/auto-translate/articles/${lang}/${filename}`;

            // Build lines exactly as requested
            const lines = [];
            // Note: replicate exact bracket/quote style from your example
            lines.push(`- Original URL: [\"${articleTitle}](${articleUrl})`);
            if (authorUrl && authorUrl !== 'undefined') {
              lines.push(`- Original author: [${authorName}](${authorUrl})`);
            } else {
              lines.push(`- Original author: ${authorName}`);
            }
            lines.push(`- Markdown file: [click to view](${rawUrl})`);
            lines.push(`- Translated file: [click to edit](${translatedEditUrl})`);
            lines.push(`- Open in github.dev editor: [click to open github.dev](${githubDevUrl})`);

            const body = lines.join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
