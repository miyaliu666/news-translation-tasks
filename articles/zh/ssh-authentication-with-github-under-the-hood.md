---
title: SSH 身份验证在 GitHub 中的运作原理
date: 2025-02-27T14:14:46.231Z
author: Vivek Agrawal
authorURL: https://www.freecodecamp.org/news/author/vkweb/
originalURL: https://www.freecodecamp.org/news/ssh-authentication-with-github-under-the-hood/
posteditor: ""
proofreader: ""
---

SSH（安全外壳）是一种用于连接和验证远程服务器的客户端-服务器协议。

<!-- more -->

身份验证意味着远程服务器可以验证与其通信的确实是您，而不是其他人冒名顶替。

您可能已经在使用 GitHub 的 SSH 身份验证，但您知道它的具体工作原理吗？在本文中，您将了解其内部工作机制及 SSH 身份验证的真正原理。

在此过程中，您将理解每个开发人员都应该了解的密码学基本概念：对称密钥加密、非对称密钥加密、密码散列函数以及数字签名。

一些开发者通常没有机会学习并理解这些密码学基础，但这些概念将对您有长期帮助。此外，它们将使您在为生产环境下的网络应用程序做出安全决策时处于更有利的位置。

所以，请系好安全带，让我们开始吧！

### 本文包括：

1.  [首先，为什么身份验证如此重要？][1]
    
2.  [对称密钥加密][2]
    
3.  [非对称密钥加密][3]
    
4.  [密码散列函数][4]
    
5.  [数字签名][5]
    
6.  [SSH 身份验证的工作原理][6]
    
7.  [总结一切][7]
    

## 首先，为什么身份验证如此重要？

当我们运行 `git push` 时，GitHub 需要验证与其交互的是正确的人。想象一下如果攻击者能够代表您执行 `git push`。

那么您所有的仓库都会在攻击者的控制之下。他们可以删除您的所有代码以及所有提交历史。

这听起来非常危险，不是吗？因此，为了验证与 GitHub 通信的确实是您，而不是攻击者，GitHub 有多种方式对您进行身份验证。

最广泛使用的 GitHub 身份验证方法是 SSH 身份验证。

在我们了解 SSH 身份验证的内部工作原理之前，我们需要理解几个基本的密码学概念，即 — 对称密钥加密、非对称密钥加密、密码散列函数和数字签名。

让我们开始吧！

## 对称密钥加密

在古代，统治者发明了各种方法来向其军队指挥官传达秘密军事信息。

其中一种最早的方法，可能被古希腊统治者使用过，后来可能被罗马人采用过，涉及使用一个称为 [**斯泰尔密码棒**][8] 的圆柱形木棒。

在军事入侵前，统治者会制作两个完全相同的圆柱形木棒，称为斯泰尔密码棒。然后他会将一个密码棒交给军队指挥官，自己保留一个。

![一根缠绕着皮革条并写有信息的斯泰尔密码棒。](https://cdn.hashnode.com/res/hashnode/image/upload/v1734514827027/b4945c3a-64d4-458b-a410-f23b1a08d9ef.png)

该装置通过将皮革条缠绕在斯泰尔密码棒上来工作。在这样做之后，统治者会在缠绕好的皮革条上写下信息，这样只有在正确缠绕后才能读取。

假设斯泰尔密码棒允许他绕着其圆周写三个字母，并沿其长度写五个字母。带有信息 `attackfromright` 的缠绕皮革条会这样显示：

```
       |   |   |   |   |   |
       | a | t | t | a | c |  |
     __| k | f | r | o | m |__|
    |  | r | i | g | h | t |
    |  |   |   |   |   |   |
```

在斯泰尔密码棒上写完信息后，统治者会展开皮革条并将其发送给军队指挥官。展开后，皮革条上的信息会被扰乱成：

```
----------------
akrtfitrgaohcmt
----------------
```

所以现在您看，即使敌方间谍截获了皮革条，信息也不会有意义。这很有趣，不是吗？巧妙地使用木棒和皮革条可能帮助一些古代统治者赢得了战斗！

当皮革条到达军队指挥官时，他会将其缠绕在自己的斯泰尔密码棒上（与统治者的完全相同），然后指挥官就能够正确理解信息。

这种斯泰尔密码棒技术实际上就是对称密钥加密的一个例子。

加密是一个过程，其中原始信息被修改（或编码），以便只有预期的接收者可以解码和查看实际信息。

原始信息称为明文，而编码后的信息称为密文。加密通过密钥将 `明文转换为密文`。

要解密信息，也就是将 `密文转换为明文`，人必须能够访问同样的密钥。

如果我们将其与斯泰尔密码棒技术进行比较，斯泰尔密码棒就是密钥。统治者只与需要知道信息内容的军队指挥官分享密钥（斯泰尔密码棒）。

```markdown
![加密时以牍木作为密钥。](https://cdn.hashnode.com/res/hashnode/image/upload/v1734519516607/75c926a3-faec-402a-8bcd-122039f47a01.png)

解密过程如下所示：

![解密时以牍木作为密钥。](https://cdn.hashnode.com/res/hashnode/image/upload/v1734519525487/de096889-332c-4482-b2df-b28ce609a8a6.png)

我们称之为对称密钥加密，因为加密和解密消息使用的是相同的密钥。

这个密钥（牍木）必须保护，不被敌人获取。如果敌人获取了这个密钥，他们就能解密消息。

但还有另外一种加密方式称为非对称密钥加密。既然你已经了解对称密钥加密，让我们继续学习非对称密钥加密。

## 非对称密钥加密

在对称密钥加密中，正如我们上面所看到的，统治者和军队指挥官使用相同的密钥来加密和解密信息。

但在非对称密钥加密中，存在两把密钥（称为密钥对）。这两把密钥中，一把是私钥，另一把是公钥。

公钥可以与任何人共享（因此称为公钥）。但私钥必须保密！绝不能透露给任何人。

![公钥可以与任何人共享。但私钥必须保密。](https://cdn.hashnode.com/res/hashnode/image/upload/v1735200860039/7aca8ffa-c33a-44e5-ab1a-181492ebefd8.png)

非对称密钥加密的有趣之处在于，如果用公钥加密消息，则只能用相应的私钥解密。没有其他密钥可以解密它。

反之亦然。如果消息是用私钥加密的，则只能用相应的公钥解密。

![公钥和私钥的数学联系图示。](https://cdn.hashnode.com/res/hashnode/image/upload/v1735120077350/b90901c8-b55c-428a-8eb4-1b8ffa65fa06.png)

这两把密钥——公钥和私钥——在数学上是相互关联的。当一把加密时，另一把解密。

稍微注意一下，非对称密钥加密也被称为公钥加密。这两个术语可以互换使用，但它们的意思是相同的。

## 加密散列函数

加密散列函数旨在接受任意长度的输入并生成固定长度的输出。这个固定长度的输出称为散列值。

一个常见的加密散列函数示例是 SHA-256。

![“freeCodeCamp.org”的 SHA-256 计算](https://cdn.hashnode.com/res/hashnode/image/upload/v1735030835833/201640c6-13b4-4b2b-9be3-88e245269bd1.png)

上图显示的是输入“freeCodeCamp.org”的 SHA-256 散列值。加密散列函数有三个非常有用的特性（我们将在接下来的部分中看到如何使用它们）。

首先**，** 从理论上讲，从散列值推导输入是不可行的。

例如，如果我们得到散列值 `c9c31315ef2257e4b7698`，我们无法推断出散列函数的输入是“freeCodeCamp.org”。

第二**，** 如果我们将相同的输入传递给散列函数，我们将得到相同的散列值作为输出。

如果我们再次将“freeCodeCamp.org”传递给 SHA-256 散列函数，我们将得到与先前调用相同的散列输出。

第三**，** 不同的输入不会共享相同的散列值。即使输入的微小变化也会生成完全不同的输出。

假设我们提供“freeCodeCamp”作为输入，而不是“freeCodeCamp.org”——我们将得到完全不同的输出。

## 数字签名

在日常生活中，你可能需要签署各种文件。这些可能是法律文件，或是孩子的成绩单，或者其他东西。

当你的签名出现在文件上时，它向另一方传达了你同意文件上所写内容的信息。

之后，你不能违背文件中所写内容。对吧？

类似地，在数字世界中，我们有数字签名——我们可以简单地称之为签名。

让我们用一个例子来理解签名的工作原理。我们有两个用户，分别叫做“Alice”和“Bob”。

Bob 想要将一些钱转到 Alice 的银行账户。因此，Bob 向 Alice 请求她的银行账户信息。

![展示爱丽丝和鲍勃的计算机相距甚远以及爱丽丝银行账号的插图。](https://cdn.hashnode.com/res/hashnode/image/upload/v1735042150046/034d26c5-b33d-4b82-aeb8-173e47cd8e8e.png)

Alice 知道数字签名并决定使用一个。最终，你将理解 Alice 为什么选择数字签名。

在 Alice 能够创建数字签名前，Alice 将她的公钥提供给 Bob（并保留私钥给自己）。

然后，Alice 创建一个数字签名并将其附在文件末尾。

![数字签名生成过程。](https://cdn.hashnode.com/res/hashnode/image/upload/v1735041977880/35313148-8820-42d7-b122-3ddf0cbaa723.png)

数字签名是通过首先将文件内容传递给类似 SHA-256 的加密散列函数创建的。在 Alice 的案例中，文件的内容是她的银行账号。
```

然后，Bob通过互联网接收到这份文件。

当Bob收到这个文件时，他会验证**签名是否有效**。

![签名验证过程。](https://cdn.hashnode.com/res/hashnode/image/upload/v1735043216695/256f7707-3f40-433f-9b00-c11b27ef01e8.png)

为了验证签名，Bob首先使用Alice的公钥解密签名。如果你还记得，Alice是通过加密哈希值生成签名的。

```
 明文                             密文  
     |                                 |
     |                                 |
     |                                 |
哈希值 --------加密--------> 签名
```

因此，当Bob解密签名时，他会得到Alice计算出的哈希值。我们称之为Alice的哈希值。

```
 密文                             明文  
     |                                 |
     |                                 |
     |                                 |
签名 --------解密--------> 哈希值
```

然后Bob取出文件中存在的银行账号，并传递给哈希函数。

最后，Bob将Alice的哈希值（解密后的签名）与他刚刚计算出的哈希值匹配。如果两个哈希值匹配，这意味着签名是有效的。

好的——但我们为什么要做这一切呢？如果签名有效，这是什么意思？

当签名验证成功时，它证明了两件事情。

首先**，**它证明了这份文件只有Alice发送。没有其他人能发送这份文件。

我们能够使用Alice的公钥解密签名说明了只有Alice发送了这份文件。

我们知道，如果某物是用私钥加密的，那么它只能用其关联的公钥解密。

所以，如果Bob能够成功地使用Alice的公钥解密签名，意味着它是用Alice的私钥加密的，对吧？

而且只有Alice可以访问她的私钥。这意味着Alice是唯一可能发送这份文件的人！

第二**，**它证明在网络传输期间，消息的内容没有被攻击者修改。

我们做了两件事来验证签名。我们解密了签名，它给了我们Alice计算出的哈希值。同时我们也对接收到的银行账号进行了哈希处理。

如果Alice计算的哈希值和Bob计算的哈希值是相同的，这意味着Alice和Bob对哈希函数的输入完全相同。

这意味着Alice发送和Bob接收到的银行账号是完全相同的。

如果攻击者在文件到达Bob之前更改了银行账号，那么Bob会收到一个被修改的银行账号。

当Bob去计算这个被修改的银行账号的哈希值时，这个哈希值与Alice计算的会不同。

因此，在匹配Alice的哈希值（解密后的签名）和Bob计算的哈希值时，匹配会失败。这将防止Bob将钱转账到错误的银行账号。

总结，当签名成功验证时，这意味着：

1. 文件是Alice发送的。
   
2. 文件的内容未被任何第三方修改。
    

现在你已经了解了对称密钥加密、非对称密钥加密、加密哈希函数和数字签名。太棒了！

我们已经建立了一个非常坚实的基础。现在理解SSH认证会变得更加容易。

## SSH认证是如何工作的

如果你还没有设置GitHub的SSH认证，完成本文后，你可以参考[GitHub关于如何操作的详细文档][9]。现在，请继续阅读到最后。

设置过程的关键是，在本地计算机上创建一对公钥和私钥。然后将你的公钥上传到你的GitHub个人资料——就是这样！

创建公私钥对后，在Ubuntu中，公私钥对存储在`~/.ssh`目录中。

![从终端显示我的公钥。](https://cdn.hashnode.com/res/hashnode/image/upload/v1735035539565/1f837d9b-9717-44fa-a5e0-5801276113df.png)

上图显示了我的公钥。我已将此公钥上传到我的GitHub个人资料中：

![显示我的GitHub个人资料设置，我的公钥已上传用于与GitHub的SSH认证。](https://cdn.hashnode.com/res/hashnode/image/upload/v1735035898284/1ef9133a-895b-4847-a7ac-6157fdcc3143.png)

现在，当我运行`git push`或任何其他希望与GitHub通信的命令时，我将通过SSH认证进行身份验证。

![客户端与GitHub服务器之间SSH认证过程的插图。](https://cdn.hashnode.com/res/hashnode/image/upload/v1735053545173/6fb293f1-f90a-4b64-b026-082d8676afae.png)

SSH是一个客户端-服务器协议。运行`git push`的计算机是SSH客户端。GitHub是SSH服务器。

客户端首先通过获取保存在`~/.ssh`中的公钥来启动认证过程。

公钥和签名被发送到 GitHub。在收到这条消息后，GitHub 会做以下两件事情：

首先，它会验证消息中提到的公钥是否连接到某个 GitHub 个人资料。因为我们将公钥上传到了 GitHub，这一步能成功通过。

其次，GitHub 使用我们上传的公钥来验证签名。

我们了解到，如果签名验证成功，这意味着只有掌握相应私钥的人才能发送这条消息。

由于只有我们拥有与已上传公钥链接的私钥，这向 GitHub 证明了确实是我们在尝试与 GitHub 通信，而不是攻击者。

现在，GitHub 完全确信我们是正确的人，成功进行了身份验证，并且我们的 `git push` 能继续进行。

看吧，当你已经学习了基础知识后，理解 SSH 身份验证变得如此简单。

![一幅描述 Cueball 打算分享其私钥的 xkcd 漫画。这是一个危险的举动！](https://cdn.hashnode.com/res/hashnode/image/upload/v1735120630613/e9a8bbba-3cc4-43e7-8369-865ab377fb87.png)

上述图片来自热门的 [xkcd 漫画][10]。其中的人物（名为 Cueball）正在考虑透露自己的私钥。希望现在你知道为什么暴露私钥是不好的。

如果你泄露了私钥，那么其他人就可以代表你进行 GitHub 身份验证。你不想让这种事情发生，对吧？ ;)

所以，一定要确保私钥只属于你自己。

## 总结

如果你读到了这里，那么恭喜你 🥳。

你已经了解了 SSH 身份验证是如何实际工作的 —— 当 GitHub 成功验证了签名后，它向 GitHub 确认是我们而不是攻击者在与它通信。

在此过程中，你建立了对对称密钥加密、非对称密钥加密、加密哈希函数和数字签名的基础理解。

感谢你与我一起学习这部分内容，希望你收获了一些新的和有价值的知识。

我会在我的 Twitter 上分享有用的想法和资源。[**你应该在那里关注我。**][11] 我会尊重你的时间。

[1]: #heading-first-why-is-authentication-so-important
[2]: #heading-symmetric-key-encryption
[3]: #heading-asymmetric-key-encryption
[4]: #heading-cryptographic-hash-functions
[5]: #heading-digital-signatures
[6]: #heading-how-ssh-authentication-works
[7]: #heading-wrapping-it-all-up
[8]: https://en.wikipedia.org/wiki/Scytale
[9]: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account
[10]: https://xkcd.com/1553/
[11]: https://twitter.com/vkwebdev

