---
title: Довідник по рядкам у JavaScript – Як працювати з рядками в JS
date: 2024-09-04T09:32:18.909Z
author: Joan Ayebola
authorURL: https://www.freecodecamp.org/news/author/joanayebola/
originalURL: https://www.freecodecamp.org/news/javascript-string-handbook
posteditor: ""
proofreader: ""
---

Рядки, в контексті JavaScript, є основними типами даних, які представляють послідовності символів. Вони є невід'ємною частиною веб-розробки, утворюючи основу для обробки та подання текстової інформації на веб-сайтах. Чи це відображення імен користувачів, обробка вводу з форм або створення динамічного контенту, рядки всюдисущі в програмуванні на JavaScript.

<!-- more -->

Маніпуляція з рядками є критично важливим аспектом програмування в JavaScript, дозволяючи розробникам ефективно перетворювати, аналізувати та подавати дані. Здатність ефективно маніпулювати рядками надає розробникам можливість створювати надійні та зручні додатки.

Ця стаття служить посібником з навігації по складному ландшафту обробки рядків у JavaScript. Занурюючись у основи, властивості, методи та передові техніки, ви здобудете глибоке розуміння того, як ефективно використовувати рядки. Мета – озброїти вас знаннями та навичками, необхідними для повного використання потенціалу рядків у JavaScript.

## Зміст

1.  **[Що таке рядки у JavaScript][1]**
2.  **[Основні операції з рядками][2]** 
    – [Одинарні та подвійні лапки][3]
3.  **[Шаблонні літерали][4]** 
    – [Основне використання][5] 
    – [Багаторядкові рядки][6] 
    – [Оцінка виразів][7] 
    – [Теговані шаблони][8] 
    – [Випадки вживання][9]
4.  **[Конструктор String][10]** 
    – [Використання конструктора String][11] 
    – [Об'єкти рядка проти примітивів рядка][12] 
    – [Перетворення об'єктів рядка в примітиви][13] 
    – [Рідкісні випадки вживання][14]
5.  **[Метод String.fromCharCode][15]** 
    – [Основне використання][16] 
    – [Створення рядків з значень Unicode][17] 
    – [Випадки вживання][18]
6.  **[Конкатенація][19]** 
    – [Використання оператора +][20] 
    – [Використання методу concat][21] 
    – [Конкатенація змінних та рядків][22] 
    – [Комбінація `String.fromCharCode` з конкатенацією][23]
7.  **[Характеристики рядків][24]** 
    – [Незмінність][25] 
    – [Послідовність символів][26]
8.  **[Методи зміни регістру][27]** 
    – [toUpperCase()][28] 
    – [toLowerCase()][29]
9.  **[Обрізка пробілів з trim(), trimStart() та trimEnd()][30]** 
    – [trim()][31] 
    – [trimStart()][32] 
    – [trimEnd()][33] 
    – [Випадки вживання][34]
10.  **[Пошук у рядках][35]** 
    – [indexOf() та lastIndexOf()][36] 
    – [Метод includes() для наявності підрядка][37] 
    – [Методи startsWith() та endsWith()][38]
11.  **[Виділення підрядків за допомогою slice() та substring()][39]** 
    – [slice()][40] 
    – [substring()][41]
12.  **[Зміна рядків][42]** 
    – [Заміна підрядків за допомогою методу replace()][43] 
    – [Розбиття рядків за допомогою split()][44] 
    – [З'єднання масивів у рядок за допомогою join()][45]
13.  **[Порівняння рядків][46]** 
    – [Перевірка на рівність за допомогою === та ==][47] 
    – [Локально-чутливе порівняння рядків за допомогою localeCompare()][48] 
    – [Порівняння рядків за допомогою `localeCompare()`][49]
14.  **[Регулярні вирази та рядки][50]** 
    – [Використання RegExp для підбору та маніпуляції з рядками][51] 
    – [Методи рядків з регулярними виразами: match(), search(), replace()][52]
15.  **[Юнікод та рядки][53]** 
    – [Рядки та Unicode у JavaScript][54] 
    – [Створення рядків Unicode][55] 
    – [Точки коду Unicode][56] 
    – [Ітерація по точках коду][57]
16.  **[Типові помилки з рядками][58]** 
    – [Приведення рядка до числа і навпаки][59] 
    – [Неочікувана поведінка з пробілами][60] 
    – [Робота зі спеціальними символами][61]
17.  **\[Кейси та приклади\](#Case Studies and Examples)** 
    – [Перевірка вводу користувача][62] 
    – [Форматування імен][63]
18.  **[Висновок][64]**

## Що таке рядки у JavaScript?

У JavaScript рядки – це послідовності символів, укладені в одинарні або подвійні лапки. Ця гнучкість дозволяє розробникам вибирати стиль лапок, виходячи з переваг або контексту. Наприклад:

```
let greeting = "Hello, World!";
let message = "JavaScript is powerful.";
```

## Основні операції з рядками

Створення рядків у JavaScript є основною операцією, і існує кілька способів досягти цього. Давайте розглянемо різні методи створення рядків у JavaScript.

### Одинарні та подвійні лапки

У JavaScript рядки можуть бути створені за допомогою одинарних лапок (`'`) або подвійних лапок (`"`). Обидва види лапок є взаємозамінними, і вибір між ними часто є питанням особистих переваг або дотриманням кодових конвенцій.

#### Одинарні лапки

```
const singleQuotedString = 'Hello, World!';
```

#### Подвійні лапки

```
const doubleQuotedString = "Hello, World!";
```

У наведених прикладах, `singleQuotedString` та `doubleQuotedString` обидва представляють той самий рядок, `"Hello, World!"`. Використання одинарних або подвійних лапок переважно є стилістичним вибором, і вми функціональна різниця між ними у JavaScript відсутня.

```md
Якщо потрібно включити символ лапок всередині рядка, що оточений тими ж лапками, можна використовувати зворотний слеш (`\`) як екрануючий символ:

```
const stringWithSingleQuotes = 'Він сказав, \'Привіт!\'';
const stringWithDoubleQuotes = "Вона сказала, \"Привіт!\"";
```

В наведених прикладах зворотний слеш перед одинарною або подвійною лапкою дозволяє трактувати її як буквальний символ всередині рядка.

#### Вибір між одинарними і подвійними лапками

Вибір між одинарними і подвійними лапками часто залежить від особистих або командних уподобань. Деякі розробники або кодові стилі можуть віддавати перевагу одному виду лапок для підтримки послідовності в кодовій базі.

Ви можете вільно перемикатися між одинарними і подвійними лапками, навіть в одному проекті, як ось так:

```
const message1 = 'Це повідомлення з одинарними лапками.';
const message2 = "Це повідомлення з подвійними лапками.";
```

але важливо бути послідовним у використанні протягом всього коду, щоб зберігати читабельність і уникати плутанини:

```
// Послідовне використання одинарних лапок
const message1 = 'Це повідомлення.';
const name = 'John';

// Послідовне використання подвійних лапок
const message2 = "Це інше повідомлення.";
const greeting = "Привіт";
```

Чи виберете ви одинарні або подвійні лапки, важливо бути послідовним у використанні, щоб забезпечити чистий та читабельний код.

## Шаблонні літерали

Шаблонні літерали, введені у ECMAScript 6 (ES6), надають більш потужний і гнучкий спосіб створення рядків в JavaScript. Вони пропонують покращений синтаксис для вбудовування змінних і виразів всередині рядків, роблячи код більш лаконічним і читабельним.

### Основи використання

```
const name = 'John';
const greeting = `Привіт, ${name}!`;

console.log(greeting); // Результат: Привіт, John!
```

В цьому прикладі рядок визначається за допомогою зворотних лапок (`` ` ``), а змінна name вбудовується в рядок за допомогою ``${}``. Цей синтаксис дозволяє безперешкодно включати змінні та вирази безпосередньо в рядок.

### Багаторядкові рядки

Шаблонні літерали також підтримують багаторядкові рядки, що робить більш зручним представлення багаторядкового тексту без необхідності в конкатенації або спеціальних символах:

```
const multilineString = `
  Це багаторядковий
  рядок, використовуючи шаблонні літерали.
`;

console.log(multilineString);

/*
Результат:
  Це багаторядковий
  рядок, використовуючи шаблонні літерали.
*/
```

### Оцінка виразів

Вирази всередині `${}` оцінюються, дозволяючи використовувати більш складні вирази і обчислення всередині рядка:

```
const num1 = 5;
const num2 = 10;
const result = `Сума ${num1} та ${num2} дорівнює ${num1 + num2}.`;

console.log(result); // Результат: Сума 5 та 10 дорівнює 15.
```

### Призначені шаблони

Шаблонні літерали також можуть використовуватися з функцією, відомою як "тег-функція", дозволяючи більш просунуту обробку рядків. Функція отримує частини рядка і значення як окремі аргументи, дозволяючи налаштовувати маніпуляцію рядками:

```
function customTag(strings, ...values) {
  let result = '';
  for (let i = 0; i < strings.length; i++) {
    result += strings[i];
    if (i < values.length) {
      result += values[i];
    }
  }
  return result;
}

const name = 'John';
const age = 30;
const taggedResult = customTag`Мене звати ${name} і мені ${age} років.`;

console.log(taggedResult); // Результат: Мене звати John і мені 30 років.
```

### Використання

#### Динамічне створення рядків

Шаблонні літерали особливо корисні при створенні рядків динамічно на основі змінних або виразів:

```
const product = 'Ноутбук';
const price = 1200;

const purchaseDetails = `Ви придбали ${product} за $${price}.`;
console.log(purchaseDetails);
// Результат: Ви придбали Ноутбук за $1200.
```

#### HTML-Шаблони

Шаблонні літерали часто використовуються в фронтенд-розробці для динамічного створення HTML-шаблонів:

```
const itemName = 'Смартфон';
const itemDescription = 'Остання модель з просунутими функціями.';

const htmlTemplate = `
  <div class="item">
    <h2>${itemName}</h2>
    <p>${itemDescription}</p>
  </div>
`;
```

Шаблонні літерали пропонують більш елегантний і виразний спосіб роботи з рядками, особливо в ситуаціях, де потрібен динамічний контент або багаторядкові рядки. Їх впровадження значно поліпшило читабельність і підтримуваність коду на JavaScript.

## Конструктор `String`

В JavaScript, конструктор `String` є способом створення об'єкта рядка. Хоча більшість розробників зазвичай створюють рядки, використовуючи рядкові літерали (одинарні або подвійні лапки) або шаблонні літерали (зворотні лапки), конструктор `String` надає альтернативний підхід для створення рядків.

### Використання конструктора `String`

```
const str = new String('Це рядок');
console.log(str); // Результат: Це рядок
```

В цьому прикладі синтаксис `new String` використовується для створення об'єкта рядка зі значенням `'Це рядок'`. Однак важливо відзначити, що використання конструктора `String` для створення рядків менш поширене у повсякденному програмуванні на JavaScript порівняно з використанням рядкових літералів.

### Об'єкти рядків проти Рядкових примітивів

Рядки, створені за допомогою конструктора `String`, є екземплярами об'єкта `String`, тоді як рядки, створені за допомогою рядкових літералів, є примітивними значеннями. Ця різниця має вплив на поведінку цих рядків:

```
const primitiveString = 'Привіт, світ!'; // примітивний рядок
const objectString = new String('Привіт, світ!'); // об'єкт рядка
```
```

Як видно з наведеного вище прикладу, `primitiveString` має тип `string`, тоді як `objectString` має тип `object`. Більшість операцій зі строками призначені для роботи з примітивними строками, і у більшості випадків використання строкових літералів є переважним.

### Перетворення строкових об'єктів на примітиви

У ситуаціях, коли у вас є строковий об'єкт, але потрібно виконати операції зі строками, які працюють з примітивами, ви можете перетворити об'єкт на примітивну строку за допомогою методу `valueOf` або `toString`:

```
const objectString = new String('Привіт, Світ!');
const primitiveString = objectString.valueOf();

console.log(typeof primitiveString); // Вивід: string
```

### Рідкісні випадки використання

Конструктор `String` рідко використовується для створення строк у типовій розробці на JavaScript. Строкові літерали та шаблонні літерали є більш лаконічними і широко прийнятими у спільноті. Однак, конструктор `String` може мати нішеві випадки використання, коли вам потрібно явно працювати зі строковими об'єктами:

```
const str1 = 'Привіт';
const str2 = new String('Привіт');

console.log(str1 === str2); // Вивід: false
```

У наведеному вище прикладі `str1` та `str2` можуть мати однакове значення, але вони не є строго рівними, оскільки `str2` є строковим об'єктом.

Підсумовуючи, хоча конструктор `String` пропонує альтернативний спосіб створення строк як об'єктів, він не є переважним методом для повсякденного створення строк у JavaScript. Використання строкових літералів є більш лаконічним, зручним для читання і відповідає загальноприйнятій практиці кодування.

## Метод `String.fromCharCode`

Метод `String.fromCharCode` у JavaScript — це спосіб створення строки з послідовності значень Unicode. Unicode — це стандартизована система кодування символів, яка присвоює унікальний номер кожному символу, забезпечуючи узгодженість у різних платформах та мовах.

### Базове використання

```
const str = String.fromCharCode(72, 101, 108, 108, 111);
console.log(str); // Вивід: Hello
```

У цьому прикладі значення Unicode `72`, `101`, `108`, `108` та `111` відповідають символам `H`, `e`, `l`, `l` та `o` відповідно. Метод `String.fromCharCode` приймає ці значення як аргументи та повертає строку, що складається з відповідних символів.

### Створення строк із значень Unicode

Ви можете використовувати `String.fromCharCode` для створення строк із серії значень Unicode. Наприклад, щоб створити строку, що представляє слово `JavaScript`:

```
const jsString = String.fromCharCode(74, 97, 118, 97, 83, 99, 114, 105, 112, 116);
console.log(jsString); // Вивід: JavaScript
```

Цей метод менш поширений для простого створення строк, але може бути корисним у ситуаціях, коли у вас є конкретні значення Unicode для представлення символів.

### Випадки використання:

#### Генерація строк із конкретними символами

```
const specialString = String.fromCharCode(9829, 9786, 8482);
console.log(specialString); // Вивід: ♥☺™
```

Це може бути корисним, коли ви хочете включити спеціальні символи або знаки у ваші строки.

#### Динамічне створення строк

```
const unicodeValues = [72, 105, 33];
const dynamicString = String.fromCharCode(...unicodeValues);
console.log(dynamicString); // Вивід: Hi!
```

Використання оператора розпакування (`...`) дозволяє передавати масив значень Unicode.

Хоча метод `String.fromCharCode` може не бути настільки поширеним, як інші методи створення строк, він надає унікальний підхід при роботі з конкретними кодуваннями символів чи коли ви маєте послідовність значень Unicode, які потрібно перетворити в строку. Розуміння випадків його використання може розширити ваш інструментарій для маніпуляції строками у JavaScript.

## Конкатенація

Конкатенація — це базова операція зі строками у JavaScript, яка передбачає об'єднання двох або більше строк у одну строку. Цей процес дозволяє створювати довші строки шляхом додавання або з'єднання наявних. У JavaScript конкатенація може бути виконана за допомогою оператора `+` або методу `concat`.

### Використання оператора `+`

Оператор `+` є найбільш поширеним способом конкатенації строк. Він працює, об'єднуючи символи двох строк для створення нової строки:

```
const firstName = 'Іван';
const lastName = 'Петрович';
const fullName = firstName + ' ' + lastName;
console.log(fullName); // Вивід: Іван Петрович
```

У цьому прикладі строки `Іван` та `Петрович` конкатенуються з пробілом між ними, щоб утворити повне ім'я `Іван Петрович`.

Ви також можете конкатенувати більше ніж дві строки:

```
const greeting = 'Привіт';
const target = 'Світ';
const message = greeting + ', ' + target + '!';
console.log(message); // Вивід: Привіт, Світ!
```

### Використання методу `concat`

Метод `concat` — це альтернативний спосіб конкатенації строк. Це метод строки, який може бути використаний для з'єднання двох або більше строк:

```
const firstName = 'Іван';
const lastName = 'Петрович';
const fullName = firstName.concat(' ', lastName);
console.log(fullName); // Вивід: Іван Петрович
```

Метод `concat` може приймати декілька аргументів, конкатенуючи їх у порядку, в якому вони передані:

```
const str1 = 'Привіт';
const str2 = ' ';
const str3 = 'Світ';
const greeting = str1.concat(str2, str3, '!');
console.log(greeting); // Вивід: Привіт Світ!
```



Конкатенація часто використовується при поєднанні змінних і рядків для створення динамічного контенту:

```
const userName = 'John';
const userGreeting = 'Welcome, ' + userName + '!';
console.log(userGreeting); // Виведе: Welcome, John!
```

Це потужний прийом, особливо в сценаріях, де потрібно конструювати повідомлення, відображати зручний для користувача вихід або генерувати динамічний контент у веб-додатках.

Важливо зазначити, що хоча конкатенація є простим та ефективним способом об'єднання рядків, вона може стати менш ефективною при роботі з великою кількістю конкатенацій. У таких випадках інші підходи, такі як використання шаблонних рядків або з'єднання масивів, можуть бути більш продуктивними.

### Поєднання `String.fromCharCode` з конкатенацією

Ви можете поєднати `String.fromCharCode` з конкатенацією для створення більш складних рядків:

```
const str = String.fromCharCode(72, 101) + 'llo';
console.log(str); // Виведе: Hello
```

У цьому прикладі значення Юнікоду для `H` і `e` поєднані з рядком `llo` за допомогою оператора `+`.

## Характеристики рядків

### Непропонуємість

Непропонованість у JavaScript означає, що після створення рядка його вміст не може бути змінений. Операції, такі як конкатенація або зміна регістру, створюють нові рядки, залишаючи оригінальний рядок незмінним. Ця концепція гарантує передбачуваність, спрощує налагодження та відповідає принципам функціонального програмування.

Безпосередня модифікація символів рядка не дозволена, що підкреслює ідею непропонованості рядків. Хоча цей підхід пропонує переваги, такі як чітка поведінка коду та простота налагодження, важливо враховувати потенційні наслідки для використання пам'яті:

```
// Створення оригінального рядка
const originalString = 'Hello World!';

// Конкатенація створює новий рядок
const newString = originalString + ' Have a great day!';

// Зміна регістру створює новий рядок
const upperCaseString = originalString.toUpperCase();

// Витяг підрядка створює новий рядок
const substring = originalString.slice(0, 5);

// Безпосереднє редагування (яке не дозволене і призведе до помилки)
// Розкоментування рядка нижче спричинить помилку.
// originalString[0] = 'J';

// Виведення результатів
console.log('Оригінальний рядок:', originalString);
console.log('Конкатенований рядок:', newString);
console.log('Рядок у верхньому регістрі:', upperCaseString);
console.log('Підрядок:', substring);
```

У цьому прикладі кожна операція (конкатенація, зміна регістру та витяг підрядка) створює новий рядок без зміни оригінального рядка. Спроба безпосередньо змінити символ в оригінальному рядку приводить до помилки, підкреслюючи непропонованість рядків у JavaScript.

Також ви могли помітити деякі методи рядків, такі як `toUpperCase()` і `slice()`, у наведених вище прикладах. Ви дізнаєтесь більше про них у наступних розділах.

### Послідовність символів

Послідовність символів у JavaScript означає лінійне розташування окремих символів, які формують рядок. Послідовність символів може містити літери, цифри, символи та пробіли. Кожен символ у послідовності має певний індекс або позицію, починаючи з `0`:

```
const greeting = 'Hello, World!';
```

У цьому прикладі рядок `'Hello, World!'` є послідовністю символів. Перший символ, `H`, знаходиться на індексі `0`, другий символ, `e`, на індексі `1`, і так далі. Весь рядок формує послідовність символів у порядку їх появи.

## Методи маніпуляції регістром

### `toUpperCase()`

Метод `toUpperCase()` перетворює всі символи в рядку на великі, надаючи простий спосіб стандартизації регістру рядка:

```
const text = "Hello, World!";
const uppercased = text.toUpperCase(); // "HELLO, WORLD!"
```

### `toLowerCase()`

І навпаки, метод `toLowerCase()` перетворює всі символи в рядку на малі:

```
const text = "Hello, World!";
const lowercased = text.toLowerCase(); // "hello, world!"
```

## Обрізання пробілів за допомогою `trim()`, `trimStart()` і `trimEnd()`

У JavaScript рядки часто містять початкові або кінцеві пробіли (пробіли, табуляції або символи нового рядка), які можуть потребувати видалення. Методи `trim()`, `trimStart()` і `trimEnd()` надають зручні способи досягти цього.

### `trim()`

Метод `trim()` видаляє пробіли з обох кінців рядка і повертає результат:

```
const stringWithWhitespace = '   Hello, World!   ';
const trimmedString = stringWithWhitespace.trim();

console.log(trimmedString); // Виведе: 'Hello, World!'
```

У цьому прикладі початкові та кінцеві пробіли в `stringWithWhitespace` видалені за допомогою `trim()`.

### `trimStart()`

Метод `trimStart()` (також відомий як `trimLeft()`) видаляє пробіли з початку (початку) рядка:

```
const stringWithLeadingWhitespace = '   Hello, World!';
const trimmedStartString = stringWithLeadingWhitespace.trimStart();

console.log(trimmedStartString); // Виведе: 'Hello, World!'
```

Тут `trimStart()` видаляє початкові пробіли з `stringWithLeadingWhitespace`.

### `trimEnd()`

Метод `trimEnd()` (також відомий як `trimRight()`) видаляє пробіли з кінця рядка:

```
const stringWithTrailingWhitespace = 'Hello, World!   ';
const trimmedEndString = stringWithTrailingWhitespace.trimEnd();

В цьому прикладі, `trimEnd()` видаляє пробіли в кінці рядка з `stringWithTrailingWhitespace`.

### Використання:

-   **Коректування введення від користувача:** При обробці введених даних від користувачів, особливо з форм або текстових полів, часто використовується обрізання пробілів на початку або в кінці.
-   **Очищення даних:** Обрізання пробілів корисне при роботі з наборами даних або зовнішніми джерелами даних для забезпечення консистентності рядкових значень.
-   **Порівняння:** Обрізання може бути корисним при порівнянні рядків, оскільки пробіли на початку або в кінці можуть впливати на результати порівняння.

**Примітка:** Ці методи не змінюють оригінальний рядок. Замість цього вони повертають новий рядок, в якому пробіли видалено. Це відповідно до концепції незмінюваності рядків у JavaScript.

## Пошук у рядках

### `indexOf()` та `lastIndexOf()`

Метод `indexOf()` використовується для знаходження першого входження підрядка в рядку. Якщо підрядок не знайдено, він поверне `-1`:

```
const sentence = "JavaScript is powerful and versatile.";
const index = sentence.indexOf("is"); // 11
```

Метод `lastIndexOf()` працює аналогічно, але починає пошук з кінця рядка, що дозволяє здійснювати зворотній пошук.

### Метод `includes()` для перевірки наявності підрядка

Метод `includes()` спрощує завдання перевірки, чи містить рядок певний підрядок, і повертає булеве значення:

```
const phrase = "To be or not to be";
const containsToBe = phrase.includes("to be"); // true
```

Цей метод особливо корисний для умовних перевірок.

### `startsWith()` та `endsWith()`

Для ситуацій, коли необхідно визначити, чи починається або закінчується рядок певним підрядком, корисні методи `startsWith()` та `endsWith()`:

```
const filename = "document.txt";
const isDocument = filename.startsWith("document"); // true
const isTextFile = filename.endsWith(".txt"); // true
```

Ці методи часто використовуються для валідації типів файлів та подібних завдань.

### Витяг підрядків за допомогою slice() і substring():

Методи `slice()` та `substring()` у JavaScript часто використовуються для витягання підрядків з рядків, але вони мають деякі відмінності у синтаксисі та функціональності.

### Метод `slice()`:

Метод `slice()` є універсальним інструментом для витягання підрядків на основі вказаних індексів. Він дозволяє витягати підрядки з будь-якої позиції у рядку та підтримує від'ємні індекси. Ось його синтаксис:

```
string.slice(startIndex, endIndex);
```

-   `startIndex`: Індекс, з якого починається вилучення.
-   `endIndex`: Індекс перед тим, якого закінчується вилучення (символ за цим індексом не включається).

#### Приклад з позитивними та від'ємними індексами:

```
let str = "Hello, World!";
let sliced1 = str.slice(7);      // Витягує "World!"
let sliced2 = str.slice(-12, -1); // Витягує "ello, World"
```

У першому прикладі `str.slice(7)` витягує підрядок, починаючи з індексу 7 до кінця. У другому прикладі `str.slice(-12, -1)` витягує підрядок, починаючи з 12 позицій від кінця до 1 позиції від кінця.

### Метод `substring()`:

Метод `substring()` схожий до `slice()`, але має інший синтаксис. Він витягує вказану частину рядка, але не підтримує від'ємні індекси. Ось його синтаксис:

```
string.substring(startIndex, endIndex);
```

-   `startIndex`: Індекс, з якого починається вилучення.
-   `endIndex`: Індекс перед тим, якого закінчується вилучення (символ за цим індексом не включається).

#### Приклад (без від'ємних індексів):

```
let str = "Hello, World!";
let subString = str.substring(7, 12); // Витягує "World"
```

На відміну від `slice()`, метод `substring()` не приймає від'ємних індексів. Спроба використовувати від'ємні індекси з `substring()` буде трактована так, ніби вони дорівнюють 0.

Хоча і `slice()`, і `substring()` можуть використовуватися для витягання підрядків, `slice()` є більш універсальним, оскільки підтримує від'ємні індекси для вилучення з кінця рядка. `substring()`, навпаки, не підтримує від'ємних індексів.

## Модифікація рядків

### Заміна підрядків за допомогою `replace()`

Метод `replace()` є важливим інструментом для заміни вказаного підрядка іншим рядком. Це особливо корисно для динамічного оновлення контенту:

```
const message = "Learning Java is fun!";
const updatedMessage = message.replace("Java", "JavaScript");
// "Learning JavaScript is fun!"
```

Цей метод зазвичай використовується в ситуаціях, коли необхідно динамічно оновлювати контент на основі взаємодії з користувачем.

### Поділ рядків за допомогою методу `split()`

Коли необхідно розділити рядок на масив підрядків на основі певного розділювача, можна використовувати метод `split()`:

```
const sentence = "JavaScript is a powerful language.";
const words = sentence.split(" "); // ["JavaScript", "is", "a", "powerful", "language."]
```

Це особливо корисно при роботі зі словами, розділеними пробілами, або даними у форматі CSV (значення, розділені комами).

### Об'єднання масивів у рядок за допомогою методу `join()`

Навпаки, метод `join()` об'єднує елементи масиву в один рядок, використовуючи вказаний розділювач.



Цей метод часто використовується для перетворення масиву значень у читабельну текстову репрезентацію.

## Порівняння рядків

### Перевірка рівності за допомогою `===` та `==`

У JavaScript порівняння рядків включає використання операторів `===` та `==`. Оператор `===` перевіряє як значення, так і тип, забезпечуючи сувору перевірку рівності:

```
const numString = "5";
const num = 5;
const isEqualStrict = numString === num; // false
```

З іншого боку, оператор `==` перевіряє на рівність з приведенням типів:

```
const isEqualLoose = numString == num; // true
```

Зазвичай рекомендується використовувати `===` для більш передбачуваних і явних порівнянь.

### Порівняння рядків з урахуванням локалі

JavaScript надає метод `localeCompare()` для порівняння рядків з урахуванням локалі. Це особливо актуально при роботі з інтернаціоналізацією та локалізацією:

```
const string1 = "apple";
const string2 = "orange";
const result = string1.localeCompare(string2);
// Результат -1, що означає, що "apple" передує "orange" у словнику.
```

`localeCompare()` враховує мовні правила для сортування та порівняння.

### Порівняння рядків за допомогою `localeCompare()`

Метод `localeCompare()` також може бути використаний для порівняння рядків з урахуванням локалі, враховуючи такі фактори, як мовні правила для сортування.

```
const string1 = "apple";
const string2 = "orange";
const result = string1.localeCompare(string2);
// Результат -1, що означає, що "apple" передує "orange" у словнику.
```

Цей метод корисний у ситуаціях, коли важливі точні мовні порівняння.

## Регулярні вирази та рядки

Регулярні вирази, часто звані regex або RegExp, надають потужний інструмент для пошуку шаблонів в рядках. Вони дозволяють здійснювати складні операції пошуку та маніпуляції на основі заданих шаблонів.

### Використання RegExp для пошуку та маніпуляції рядками

Регулярні вирази можуть бути створені за допомогою конструктора `RegExp` або виражені безпосередньо між слешами (`/.../`). Вони пропонують широкий спектр опцій для пошуку шаблонів, таких як пошук певних символів, груп або діапазонів.

### Методи рядків з регулярними виразами: `match()`, `search()`, `replace()`

#### `match()`

Метод `match()` використовується для отримання збігів, коли рядок відповідає регулярному виразу. Він повертає масив збігів або `null`, якщо збігів не знайдено:

```
const sentence = "The cat and the hat";
const matches = sentence.match(/at/g); // ["at", "at"]
```

В цьому прикладі регулярний вираз `/at/g` використовує глобальний прапорець `g` і шукає появи `at` в рядку.

**Примітка:** Якщо глобальний прапорець (`g`) не використовується в регулярному виразі, `match()` повертає тільки перший збіг.

#### `search()`

Метод `search()` повертає індекс першого збігу регулярного виразу в рядку. Якщо збіг не знайдено, він повертає `-1`:

```
const sentence = "The cat and the hat";
const index = sentence.search(/at/); // 7
```

В цьому випадку регулярний вираз `/at/` шукає першу появу `at` в рядку.

#### `replace()`

Метод `replace()` використовується для заміни появ підрядка або шаблону на інший рядок. Регулярні вирази розширюють його можливості, дозволяючи робити більш складні заміни:

```
const sentence = "The cat and the hat";
const updatedSentence = sentence.replace(/at/g, "og"); // "The cog and the hog"
```

У цьому прикладі регулярний вираз `/at/g` використовується для заміни всіх появ `at` на `og`.

**Примітка:** Якщо глобальний прапорець (`g`) не використовується в регулярному виразі, `replace()` замінить тільки перше появу підрядка або шаблону в оригінальному рядку.

## Unicode та рядки

### Unicode у короткому підсумку

Unicode - це стандартизована система кодування символів, яка присвоює унікальний числовий значення (кодова точка) кожному символу, знаку або гліфу в майже кожній системі письма, що використовується в усьому світі. Вона покликана надати універсальне кодування, що охоплює всі системи письма, дозволяючи комп'ютерам представляти та обробляти текст послідовно.

### Рядки та Unicode у JavaScript

У JavaScript рядки є послідовностями кодових одиниць UTF-16, де кожна кодова одиниця представляє 16-бітове значення. Це означає, що JavaScript використовує підмножину повного діапазону Unicode (який виходить за межі 16-бітового діапазону) для представлення символів.

### Створення Unicode рядків

```
const unicodeString = 'Hello, \u{1F60A}'; // Використання Unicode escape sequence
console.log(unicodeString); // Вивід: Hello, 😊
```

У наведеному вище прикладі Unicode escape sequence `\u{1F60A}` представляє емодзі обличчя, що посміхається. JavaScript інтерпретує цю escape sequence і відображає відповідний Unicode символ.

### Кодові точки Unicode

JavaScript надає методи для роботи з кодовими точками Unicode безпосередньо. Метод `codePointAt()` повертає кодову точку Unicode на конкретному індексі в рядку:

```
const greeting = 'Hello, World!';
const codePoint = greeting.codePointAt(7);
console.log(codePoint); // Вивід: 87 (кодова точка Unicode для 'W')
```

Цикл `for...of` можна використовувати для ітерації по фактичних символах у рядку, враховуючи сурогатні пари для символів за межами Основної багатомовної площини (BMP):

```
const astralString = '𝒜B'; // Рядок із символами поза BMP
for (let char of astralString) {
  console.log(char); // Вивід: 𝒜, B
}
```

Цикл коректно ітерує обидва символи у рядку, навіть якщо `𝒜` знаходиться поза BMP.

### Використання

-   **Підтримка багатомовності:** Unicode дозволяє JavaScript обробляти текст різними мовами та системами письма, що дає змогу створювати багатомовні додатки.
-   **Емодзі та спеціальні символи:** Unicode надає стандартизований спосіб представлення емодзі, спеціальних символів й символів поза межами основного латинського алфавіту.
-   **Обмін даними:** Unicode є важливим для обміну даними між системами та мовами, забезпечуючи послідовне представлення та інтерпретацію тексту.

Розуміння Unicode є важливим для роботи з різноманітними наборами символів і знаків у рядках JavaScript, особливо в глобалізованому та багатомовному програмному середовищі.

## Загальні помилки роботи з рядками

### Примусове перетворення рядків і чисел

Однією з поширених помилок є ненавмисне перетворення між рядками і числами. JavaScript може виконувати неявне перетворення типів, що призводить до неочікуваної поведінки:

```
const num = 5;
const str = '10';

const result = num + str;
console.log(result); // Вивід: 510 (а не 15!)
```

Щоб уникнути цього, переконайтеся, що ви явно перетворюєте типи за необхідності:

```
const num = 5;
const str = '10';

const result = num + parseInt(str);
console.log(result); // Вивід: 15
```

### Неочікувана поведінка з пробілами

Пробільні символи, такі як пробіли та табуляція, можуть призводити до неочікуваних результатів за несправного опрацювання. Наприклад:

```
const word1 = 'Hello';
const word2 = ' World';

const result = word1 + word2;
console.log(result); // Вивід: Hello World (без пробілу між ними)
```

Щоб вирішити це, обрізайте пробіли за допомогою методу `trim`:

```
const word1 = 'Hello';
const word2 = ' World';

const result = word1.trim() + word2.trim();
console.log(result); // Вивід: HelloWorld
```

### Робота зі спеціальними символами

Спеціальні символи, такі як лапки або зворотні скісні лінії, можуть спричинити проблеми під час включення до рядків:

```
const message = 'He said, 'JavaScript is powerful!'';
```

Щоб обробити це, екрануйте спеціальні символи за допомогою зворотніх скісних ліній:

```
const message = 'He said, \'JavaScript is powerful!\'';
```

## Практичні приклади

Розглянемо реальний сценарій, де маніпулювання рядками є необхідним.

### Валідація введення користувача

Припустимо, ви розробляєте форму, що вимагає від користувача введення адреси електронної пошти. Для валідації введення можна використовувати методи роботи з рядками:

```
function validateEmail(email) {
  // Перевірка наявності символу @
  if (!email.includes('@')) {
    return false;
  }

  // Перевірка, чи закінчується email на правильний домен (наприклад, .com, .org)
  const domain = email.split('@')[1];
  const validDomains = ['com', 'org', 'net'];
  if (!validDomains.includes(domain.split('.')[1])) {
    return false;
  }

  return true;
}

const userEmail = 'user@example.com';
if (validateEmail(userEmail)) {
  console.log('Електронна пошта є дійсною!');
} else {
  console.log('Неправильний формат електронної пошти.');
}
```

### Форматування імен

Припустимо, у вас є список імен у форматі "Ім'я Прізвище," і ви хочете показати їх у форматі "Прізвище, Ім'я." Ви можете досягти цього за допомогою маніпулювання рядками:

```
function formatNames(names) {
  return names.map((name) => {
    const [first, last] = name.split(' ');
    return `${last}, ${first}`;
  });
}

const originalNames = ['John Doe', 'Jane Smith', 'Bob Johnson'];
const formattedNames = formatNames(originalNames);
console.log(formattedNames);
// Вивід: ['Doe, John', 'Smith, Jane', 'Johnson, Bob']
```

## Висновок

У цій статті ми розглянули основи роботи з рядками у JavaScript. Ми дослідили базові операції, такі як конкатенація і знаходження довжини рядка. Крім того, ми розглянули різні методи рядків для зміни регістру, вилучення підрядків, пошуку підрядків, заміни підрядків і розбиття рядків.

Опанування маніпуляцією рядками вимагає практики та експериментування. Працюючи над більше проєктами, ви будете стикатися з різними ситуаціями, що вимагають креативних рішень щодо рядків. Не соромтеся експериментувати з різними методами та підходами, щоб покращити свої навички.

Солідне розуміння методів роботи з рядками є важливим для написання чистого, ефективного і безпомилкового JavaScript-коду. Продовжуйте ваше програмне подорож, пам'ятайте, що рядки є фундаментальною частиною багатьох додатків, і здатність ефективно ними маніпулювати значно сприятиме вашому успіху як JavaScript-розробника. Продовжуйте кодувати, продовжуйте навчатися і насолоджуйтеся світом JavaScript!

[1]: #heading-what-are-strings-in-javascript
[2]: #heading-basic-string-operations
[3]: #heading-single-and-double-quotes
[4]: #heading-template-literals
[5]: #heading-basic-usage
[6]: #heading-multiline-strings
[7]: #heading-expression-evaluation
[8]: #heading-tagged-templates
[9]: #heading-use-cases
[10]: #heading-the-string-constructor
[11]: #heading-using-the-string-constructor
[12]: #heading-string-objects-vs-string-primitives
[13]: #heading-converting-string-objects-to-primitives
[14]: #heading-rare-use-cases
[15]: #heading-the-stringfromcharcode-method
[16]: #heading-basic-usage
[17]: #heading-creating-strings-from-unicode-values
[18]: #heading-use-cases
[19]: #heading-concatenation
[20]: #heading-using-the-operator
[21]: #heading-using-the-concat-method
[22]: #heading-concatenating-variables-and-strings
[23]: #heading-combining-stringfromcharcode-with-concatenation
[24]: #heading-characteristics-of-strings
[25]: #heading-immutability
[26]: #heading-sequence-of-characters
[27]: #heading-case-manipulation-methods
[28]: #heading-touppercase
[29]: #heading-tolowercase
[30]: #heading-trimming-whitespaces-with-trim-trimstart-and-trimend
[31]: #heading-trim
[32]: #heading-trimstart
[33]: https://www.freecodecamp.org/news/p/e2ef5e41-04ae-40a6-b5a5-8915616f1bd3/trimend-
[34]: #heading-use-cases
[35]: #heading-string-searching
[36]: #heading-indexof-and-lastindexof
[37]: #heading-the-includes-method-for-substring-presence
[38]: #heading-startswith-and-endswith
[39]: #heading-substring-extraction-with-slice-and-substring
[40]: #slice-
[41]: #substring-
[42]: #heading-modifying-strings
[43]: #heading-replacing-substrings-with-replace
[44]: #heading-splitting-strings-with-split
[45]: #heading-joining-arrays-into-a-string-with-join
[46]: #heading-string-comparison
[47]: #heading-equality-checks-with-and
[48]: #heading-locale-sensitive-string-comparison
[49]: #heading-comparing-strings-using-localecompare
[50]: #heading-regular-expressions-and-strings
[51]: #heading-using-regexp-for-string-matching-and-manipulation
[52]: #heading-string-methods-with-regular-expressions-match-search-replace
[53]: #heading-unicode-and-strings
[54]: #heading-strings-and-unicode-in-javascript
[55]: #heading-creating-unicode-strings
[56]: #heading-unicode-code-points
[57]: #heading-code-point-iteration
[58]: #heading-common-string-pitfalls
[59]: #heading-string-vs-number-coercion
[60]: #heading-unexpected-behavior-with-whitespace
[61]: #heading-dealing-with-special-characters
[62]: #heading-user-input-validation
[63]: #heading-formatting-names
[64]: #heading-conclusion

